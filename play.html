<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR CODES</title>
    <style>
        body {
          background-color: white;
          color: black;
          margin: 0;
          overflow: hidden;
        }
        canvas {
          position: absolute;
          left: 0;
          top: 0;
          z-index: -1;
        }
    </style>
</head>
<body>

    <p>Rotate your device:</p>
    gamma(x):<a id='gamma'> </a><sup>o</sup><br>
    beta(y):<a id='beta'> </a><sup>o</sup><br>
    alpha(z):<a id='alpha'> </a><sup>o</sup><br>

<script>
    // Device orientation handler
    function handleOrientation(event) {
      var x = event.gamma; // In degrees [-90,90]
      var y = event.beta;  // In degrees [-180,180]
      var z = event.alpha; // In degrees [0,360]
    
      // Display orientation values
      document.getElementById("gamma").innerHTML = Math.round(x);
      document.getElementById("beta").innerHTML = Math.round(y);
      document.getElementById("alpha").innerHTML = Math.round(z);

      // Update gravity based on device orientation
      const scale = 0.02;
      engine.world.gravity.y = y * scale;
      engine.world.gravity.x = x * scale;
    }

    window.addEventListener('deviceorientation', handleOrientation);

    // Matter.js aliases
    var Engine = Matter.Engine,
        World = Matter.World,
        Bodies = Matter.Bodies;

    // Create the Matter.js engine
    var engine = Engine.create();

    // Create a black square
    var square = Bodies.rectangle(200, 300, 50, 50, {
      render: {
        fillStyle: 'black',
        strokeStyle: 'black'
      }
    });

    // Create static walls to keep the square on screen
    var wallSettings = {
      size: 2000,
      isStatic: true,
      render: {
        fillStyle: 'black',
        strokeStyle: 'black'
      }
    };
    World.add(engine.world, [
      square,
      Bodies.rectangle(window.innerWidth / 2, -wallSettings.size / 2, window.innerWidth, wallSettings.size, wallSettings), // Top wall
      Bodies.rectangle(window.innerWidth / 2, window.innerHeight + wallSettings.size / 2, window.innerWidth, wallSettings.size, wallSettings), // Bottom wall
      Bodies.rectangle(-wallSettings.size / 2, window.innerHeight / 2, wallSettings.size, window.innerHeight, wallSettings), // Left wall
      Bodies.rectangle(window.innerWidth + wallSettings.size / 2, window.innerHeight / 2, wallSettings.size, window.innerHeight, wallSettings) // Right wall
    ]);

    // Run the engine
    Engine.run(engine);

    // Render
    var canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);

    window.onresize = function() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    (function render() {
      var bodies = Matter.Composite.allBodies(engine.world);
      window.requestAnimationFrame(render);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Render the square
      for (var i = 0; i < bodies.length; i++) {
        var vertices = bodies[i].vertices;
        ctx.beginPath();
        ctx.moveTo(vertices[0].x, vertices[0].y);
        for (var j = 1; j < vertices.length; j++) {
          ctx.lineTo(vertices[j].x, vertices[j].y);
        }
        ctx.closePath();
        ctx.fillStyle = bodies[i].render.fillStyle;
        ctx.fill();
      }
    })();

    // Move the square to mouse position on click
    function getMousePos(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    canvas.addEventListener('mousedown', function(evt) {
      Matter.Body.setPosition(square, getMousePos(canvas, evt));
    }, false);
</script>

</body>
</html>
